Index: xorg-server-1.3.0.0/hw/kdrive/glamo/Makefile.am
===================================================================
--- xorg-server-1.3.0.0.orig/hw/kdrive/glamo/Makefile.am	2007-11-28 18:44:27.000000000 +0100
+++ xorg-server-1.3.0.0/hw/kdrive/glamo/Makefile.am	2007-11-28 18:44:28.000000000 +0100
@@ -20,6 +20,7 @@
 noinst_LIBRARIES = libglamo.a
 
 libglamo_a_SOURCES = 	\
+	glamo-log.h	\
 	glamo_dma.c	\
 	glamo_dma.h	\
 	glamo_draw.c	\
Index: xorg-server-1.3.0.0/hw/kdrive/glamo/glamo-log.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server-1.3.0.0/hw/kdrive/glamo/glamo-log.h	2007-11-29 09:05:53.000000000 +0100
@@ -0,0 +1,63 @@
+/*
+ * Copyright © 2007 OpenMoko, Inc.
+ *
+ * This driver is based on Xati,
+ * Copyright © 2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author: Dodji Seketeli <dodji@openedhand.com>
+ */
+#ifndef _GLAMO_LOG_H_
+#define _GLAMO_LOG_H_
+#ifdef HAVE_CONFIG_H
+#include <kdrive-config.h>
+#endif
+
+#include <assert.h>
+#include "os.h"
+
+#ifdef NDEBUG
+/*we are not in debug mode*/
+#define GLAMO_LOG
+#define GLAMO_LOG_ERROR
+
+#else /*NDEBUG*/
+
+#define ERROR_LOG_LEVEL 3
+#define INFO_LOG_LEVEL 4
+
+#ifndef GLAMO_LOG
+#define GLAMO_LOG(...) \
+LogMessageVerb(X_NOTICE, INFO_LOG_LEVEL, "in %s:%d:%s: ",\
+               __FILE__, __LINE__, __func__) ; \
+LogMessageVerb(X_NOTICE, INFO_LOG_LEVEL, __VA_ARGS__)
+#endif /*GLAMO_LOG*/
+
+#ifndef GLAMO_LOG_ERROR
+#define GLAMO_LOG_ERROR(...) \
+LogMessageVerb(X_NOTICE, ERROR_LOG_LEVEL, "Error:in %s:%d:%s: ",\
+               __FILE__, __LINE__, __func__) ; \
+LogMessageVerb(X_NOTICE, ERROR_LOG_LEVEL, __VA_ARGS__)
+#endif /*GLAMO_LOG_ERROR*/
+
+#endif /*NDEBUG*/
+
+#endif /*_GLAMO_LOG_H_*/
+
Index: xorg-server-1.3.0.0/hw/kdrive/glamo/glamo_draw.c
===================================================================
--- xorg-server-1.3.0.0.orig/hw/kdrive/glamo/glamo_draw.c	2007-11-28 18:44:27.000000000 +0100
+++ xorg-server-1.3.0.0/hw/kdrive/glamo/glamo_draw.c	2007-11-29 09:33:11.000000000 +0100
@@ -26,6 +26,7 @@
 #ifdef HAVE_CONFIG_H
 #include <kdrive-config.h>
 #endif
+#include "glamo-log.h"
 #include "glamo.h"
 #include "glamo-regs.h"
 #include "glamo_dma.h"
@@ -90,45 +91,11 @@
 	KdScreenPriv(pScreen);
 	GLAMOScreenInfo(pScreenPriv);
 
-	ENTER_DRAW(0);
+	GLAMO_LOG("enter");
 	GLAMOWaitIdle(glamos);
-	LEAVE_DRAW(0);
+	GLAMO_LOG("leave");
 }
 
-#if GLAMO_TRACE_DRAW
-void
-GLAMOEnterDraw (PixmapPtr pPix, const char *function)
-{
-    if (pPix != NULL) {
-	KdScreenPriv(pPix->drawable.pScreen);
-	CARD32 offset;
-
-	offset = ((CARD8 *)pPix->devPrivate.ptr -
-		  pScreenPriv->screen->memory_base);
-
-	ErrorF ("Enter %s 0x%x (%dx%dx%d/%d)\n", function, (unsigned int) offset,
-	    pPix->drawable.width, pPix->drawable.height, pPix->drawable.depth,
-	    (unsigned int) pPix->drawable.bitsPerPixel);
-    } else
-	ErrorF ("Enter %s\n", function);
-}
-
-void
-GLAMOLeaveDraw (PixmapPtr pPix, const char *function)
-{
-    if (pPix != NULL) {
-	KdScreenPriv(pPix->drawable.pScreen);
-	CARD32 offset;
-
-	offset = ((CARD8 *)pPix->devPrivate.ptr -
-		  pScreenPriv->screen->memory_base);
-
-	ErrorF ("Leave %s 0x%x\n", function, (unsigned int) offset);
-    } else
-	ErrorF ("Leave %s\n", function);
-}
-#endif
-
 static Bool
 GLAMOPrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
 {
@@ -152,7 +119,7 @@
 			pScreenPriv->screen->memory_base);
 	pitch = pPix->devKind;
 
-	ENTER_DRAW(pPix);
+	GLAMO_LOG("enter");
 
 	BEGIN_DMA(12);
 	OUT_REG(GLAMO_REG_2D_DST_ADDRL, offset & 0xffff);
@@ -163,7 +130,7 @@
 	OUT_REG(GLAMO_REG_2D_COMMAND2, settings);
 	END_DMA();
 
-	LEAVE_DRAW(pPix);
+	GLAMO_LOG("leave");
 
 	return TRUE;
 }
@@ -171,7 +138,7 @@
 static void
 GLAMOSolid(int x1, int y1, int x2, int y2)
 {
-	ENTER_DRAW(0);
+	GLAMO_LOG("enter");
 	GLAMOScreenInfo *glamos = accel_glamos;
 	RING_LOCALS;
 
@@ -184,14 +151,12 @@
 	OUT_REG(GLAMO_REG_2D_ID1, 0);
 	OUT_REG(GLAMO_REG_2D_ID2, 0);
 	END_DMA();
-	LEAVE_DRAW(0);
+	GLAMO_LOG("leave");
 }
 
 static void
 GLAMODoneSolid(void)
 {
-	ENTER_DRAW(0);
-	LEAVE_DRAW(0);
 }
 
 static Bool
@@ -204,6 +169,8 @@
 	FbBits mask;
 	RING_LOCALS;
 
+	GLAMO_LOG("enter");
+
 	if (pSrc->drawable.bitsPerPixel != 16 ||
 	    pDst->drawable.bitsPerPixel != 16)
 		GLAMO_FALLBACK(("Only 16bpp is supported"));
@@ -224,8 +191,6 @@
 
 	settings = GLAMOBltRop[alu] << 8;
 
-	ENTER_DRAW (pDst);
-
 	BEGIN_DMA(16);
 
 	OUT_REG(GLAMO_REG_2D_SRC_ADDRL, src_offset & 0xffff);
@@ -241,7 +206,7 @@
 
 	END_DMA();
 
-	LEAVE_DRAW(pDst);
+	GLAMO_LOG("leave");
 
 	return TRUE;
 }
@@ -268,8 +233,10 @@
 static void
 GLAMODoneCopy(void)
 {
-	ENTER_DRAW(0);
-	LEAVE_DRAW(0);
+	GLAMOScreenInfo *glamos = accel_glamos;
+	GLAMO_LOG("enter");
+        GLAMOFlushIndirect(glamos, 1);
+	GLAMO_LOG("leave");
 }
 
 static Bool
@@ -279,6 +246,7 @@
 	CARD8 *dst_offset;
 	int dst_pitch;
 
+        GLAMO_LOG("enter");
 	dst_offset = (CARD8 *)pDst->devPrivate.ptr;
 	dst_pitch = pDst->devKind;
 	width = pDst->drawable.width;
@@ -294,83 +262,9 @@
 		src += src_pitch;
 	}
 
-	ErrorF("hostdata upload %d,%d %dbpp\n", width, height, bpp);
-
 	return TRUE;
 }
 
-
-#if 0
-static Bool
-GLAMOUploadToScratch(PixmapPtr pSrc, PixmapPtr pDst)
-{
-	KdScreenPriv(pSrc->drawable.pScreen);
-	GLAMOCardInfo(pScreenPriv);
-	GLAMOScreenInfo(pScreenPriv);
-	int dst_pitch, src_pitch, w, i, size, bytes;
-	unsigned char *dst, *src;
-	RING_LOCALS;
-
-	ENTER_DRAW(pSrc);
-	/* Align width to log 2, useful for R128 composite.  This should be a
-	 * KAA flag we check for (and supported in kaa.c in general) since many
-	 * older bits of hardware are going to want POT pitches.
-	 */
-	w = pSrc->drawable.width;
-	if (glamos->kaa.flags & KAA_OFFSCREEN_ALIGN_POT)
-		w = 1 << (GLAMOLog2(w - 1) + 1);
-	dst_pitch = (w * pSrc->drawable.bitsPerPixel / 8 +
-	    glamos->kaa.pitchAlign - 1) & ~(glamos->kaa.pitchAlign - 1);
-
-	size = dst_pitch * pSrc->drawable.height;
-	if (size > glamos->scratch_area->size)
-		GLAMO_FALLBACK(("Pixmap too large for scratch (%d,%d)\n",
-		    pSrc->drawable.width, pSrc->drawable.height));
-
-	glamos->scratch_next = (glamos->scratch_next + glamos->kaa.offsetAlign - 1) &
-	    ~(glamos->kaa.offsetAlign - 1);
-	if (glamos->scratch_next + size > glamos->scratch_area->offset +
-	    glamos->scratch_area->size) {
-		/* Only sync when we've used all of the scratch area. */
-		kaaWaitSync(pSrc->drawable.pScreen);
-		glamos->scratch_next = glamos->scratch_area->offset;
-	}
-	memcpy(pDst, pSrc, sizeof(*pDst));
-	pDst->devKind = dst_pitch;
-	pDst->devPrivate.ptr = pScreenPriv->screen->memory_base +
-	    glamos->scratch_next;
-	glamos->scratch_next += size;
-
-	src = pSrc->devPrivate.ptr;
-	src_pitch = pSrc->devKind;
-	dst = pDst->devPrivate.ptr;
-	bytes = src_pitch < dst_pitch ? src_pitch : dst_pitch;
-
-	i = pSrc->drawable.height;
-	while (i--) {
-		memcpy(dst, src, bytes);
-		dst += dst_pitch;
-		src += src_pitch;
-	}
-
-	/* Flush the pixel cache */
-	if (glamoc->is_3362) {
-		BEGIN_DMA(4);
-		OUT_REG(RADEON_REG_RB3D_DSTCACHE_CTLSTAT,
-		    RADEON_RB3D_DC_FLUSH_ALL);
-		OUT_REG(GLAMO_REG_WAIT_UNTIL, RADEON_WAIT_HOST_IDLECLEAN);
-		END_DMA();
-	} else {
-		BEGIN_DMA(2);
-		OUT_REG(R128_REG_PC_GUI_CTLSTAT, R128_PC_FLUSH_ALL);
-		END_DMA();
-	}
-
-	LEAVE_DRAW(pSrc);
-	return TRUE;
-}
-#endif
-
 static void
 GLAMOBlockHandler(pointer blockData, OSTimePtr timeout, pointer readmask)
 {
Index: xorg-server-1.3.0.0/hw/kdrive/glamo/glamo_dma.c
===================================================================
--- xorg-server-1.3.0.0.orig/hw/kdrive/glamo/glamo_dma.c	2007-11-28 18:44:27.000000000 +0100
+++ xorg-server-1.3.0.0/hw/kdrive/glamo/glamo_dma.c	2007-11-28 22:13:23.000000000 +0100
@@ -25,6 +25,7 @@
 
 #include <sys/time.h>
 
+#include "glamo-log.h"
 #include "glamo.h"
 #include "glamo-regs.h"
 #include "glamo_dma.h"
@@ -35,9 +36,7 @@
 #include "glamo_sarea.h"
 #endif /* USE_DRI */
 
-#define DEBUG_FIFO 1
-
-#if DEBUG_FIFO
+#ifndef NDEBUG
 static void
 GLAMODebugFifo(GLAMOScreenInfo *glamos)
 {
@@ -273,7 +272,7 @@
 		count--;
 	}
 	if (TIMEDOUT()) {
-		ErrorF("Timeout submitting packets, resetting...\n");
+		GLAMO_LOG_ERROR("Timeout submitting packets, resetting...\n");
 		GLAMOEngineReset(glamos->screen->pScreen, GLAMO_ENGINE_CQ);
 		GLAMODrawSetup(glamos->screen->pScreen);
 	}
@@ -292,11 +291,6 @@
 	if ((glamos->indirectStart == buf->used) && !discard)
 		return;
 
-#if DEBUG_FIFO
-	ErrorF("Dispatching %d DWORDS\n", (buf->used - glamos->indirectStart) /
-	    4);
-#endif
-
 #ifdef USE_DRI
 	if (glamos->using_dri) {
 		buf->drmBuf->used = buf->used;
@@ -384,11 +378,6 @@
 	glamos->indirectBuffer = GLAMOGetDMABuffer(glamos);
 	if (glamos->indirectBuffer == FALSE)
 		FatalError("Failed to allocate DMA buffer.\n");
-
-	if (glamos->using_dri)
-		ErrorF("Initialized DRI DMA\n");
-	else
-		ErrorF("Initialized DMA\n");
 }
 
 void
Index: xorg-server-1.3.0.0/configure.ac
===================================================================
--- xorg-server-1.3.0.0.orig/configure.ac	2007-11-29 09:07:21.000000000 +0100
+++ xorg-server-1.3.0.0/configure.ac	2007-11-29 09:15:38.000000000 +0100
@@ -866,6 +866,10 @@
 
 if ! test "x$DEBUGGING" = xyes; then
   AC_DEFINE(NDEBUG, 1, [Disable some debugging code])
+  AC_MSG_NOTICE([disabled debugging])
+else
+  AC_MSG_NOTICE([enabled debugging])
+
 fi
 
 AC_DEFINE(USE_RGB_TXT, 1, [Use rgb.txt directly])
