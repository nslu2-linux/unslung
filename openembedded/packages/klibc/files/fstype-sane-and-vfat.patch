Patch to compile fstype util against "normal" libc (glibc/uclicb), and to
add vfat detection.

--- klibc-1.1.1/utils/fstype.c.org	2005-09-06 23:49:34.000000000 +0300
+++ klibc-1.1.1/utils/fstype.c	2007-11-24 01:07:26.000000000 +0200
@@ -13,11 +13,18 @@
  */
 
 #include <sys/types.h>
+#include <linux/types.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 #include <endian.h>
 #include <netinet/in.h>
+#if __BYTE_ORDER == __BIG_ENDIAN
+#include <linux/byteorder/big_endian.h> 
+#else 
+#include <linux/byteorder/little_endian.h> 
+#endif 
+
 
 #define cpu_to_be32(x) __cpu_to_be32(x)	/* Needed by romfs_fs.h */
 
@@ -105,6 +112,18 @@
 	return 0;
 }
 
+static int vfat_image(const unsigned char *buf, unsigned long *blocks)
+{
+        const struct romfs_super_block *sb =
+		(const struct romfs_super_block *)buf;
+	if (!strncmp(buf + 54, "FAT12   ", 8)
+	    || !strncmp(buf + 54, "FAT16   ", 8)
+	    || !strncmp(buf + 82, "FAT32   ", 8))
+		return 1;
+
+	return 0;
+}
+
 static int minix_image(const unsigned char *buf, unsigned long *blocks)
 {
 	const struct minix_super_block *sb =
@@ -167,8 +186,6 @@
 		(const struct xfs_sb *)buf;
 
 	if (__be32_to_cpu(sb->sb_magicnum) == XFS_SB_MAGIC) {
-		*blocks = __be64_to_cpu(sb->sb_dblocks) *
-			  (__be32_to_cpu(sb->sb_blocksize) / BLOCK_SIZE);
 		return 1;
 	}
 	return 0;
@@ -184,6 +201,7 @@
 	{ 0,	"gzip",		gzip_image	},
 	{ 0,	"cramfs",	cramfs_image	},
 	{ 0,	"romfs",	romfs_image	},
+	{ 0,	"vfat",		vfat_image	},
 	{ 0,	"xfs",		xfs_image	},
 	{ 1,	"minix",	minix_image	},
 	{ 1,	"ext3",		ext3_image	},
